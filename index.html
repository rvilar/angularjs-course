<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Introducció a AngularJS</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>AngularJS</h1>
					<h3>Una introducció</h3>
					<p>
						<small>Creat per en <a href="http://https://twitter.com/rvilar">Ramon Vilar</a> d'<a href="http://ymbra.com">Ymbra</a></small>
					</p>
				</section>
				<section>
					<h2>Introducció</h2>
					<p>AngularJS és un framework JS per a crear interfícies d'aplicaciones riques creat per Google.</p>
					<p class="fragment">Es basa en una arquitectura MVC i seguint OOP.</p>
				</section>
				<section>
					<section>
						<h2>Conceptes bàsics</h2>
					</section>
					<section>
						<h2>Classes</h2>
						<p>ES6 introdueix el conceptes de classe típic de qualsevol llenguatge de programació OO.</p>
						<pre><code class="js">class Polygon {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}</code></pre>
					</section>
					<section>
						<h2>Mòduls</h2>
						<p>ES6 introdueix també el concepte de mòdul nadiu (ja fa anys que es venen usant a través de tècniques JS).</p>
						<p class="fragment">La diferència principal és que usen de forma automàtica el mode estricte (<code class="js">"use strict";</code>) i que tot el que es declari en un mòdul és local en aquest.</p>
						<p class="fragment">Cal importar i exportar tot.</p>
					</section>
					<section>
						<h2>Mòduls</h2>
						<pre><code class="js" data-noescape>// foo.js

export function detectFoo(zone, options) {
  // My code.
}</code></pre>
						<pre><code class="js">// bar.js

import {detectFoo} from "foo.js";

function go() {
    var foo = detectFoo(canvas);
    // ...
}</code></pre>
					</section>
					<section>
						<h2>TypeScript</h2>
						<p>AngularJS està escrit (i usa) TypeScript</p>
						<p class="fragment">És un llenguatge de programació desenvolupat per Microsoft.</p>
						<p class="fragment">És un superconjunt de JavaScript que afegeix, entre d'altres, tipatge estàtic i objectes basats en classes.</p>
					</section>
					<section>
						<h2>Anotacions</h2>
						<p>Una anotació és una "funció" que afegeix informació a una funció, una variable o una classe.</p>
						<pre><code class="js">class Example {
  a() {}
  @readonly
  b() {}
}</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Angular CLI</h2>
						<p>És una interfície per línia de comandes per Angular.</p>
						<p class="fragment">Ens facilita moltes operaciones diàries amb Angular tot estalviant-nos temps.</p>
						<p class="fragment">Per instal·lar és tan fàcil com:</p>
						<pre class="fragment"><code>npm install -g @angular/cli</code></pre>
					</section>
					<section>
						<h2>Crear una aplicació</h2>
						<p>Podem crear una aplicació Angular i servir-la des del nostre ordinador fent.</p>
						<pre><code>ng new my-app
cd my-app
ng serve</code></pre>
					</section>
					<section>
						<h2>Generar codi</h2>
						<p>Angular CLI ens proporciona una comanda per a poder crear fàcilment diversos elements.</p>
						<pre><code>// Generates a component.
ng generate component MyComponent

// Generates a service.
ng generate service MyService</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Anatomia d'una aplicació</h2>
						<p>Anem a crear la nostra primera aplicació Angular</p>
						<p class="fragment">Anem a un directori de treball i executem el següent:</p>
						<pre class="fragment"><code>ng new my-app
cd my-app
ng serve --open</code></pre>
						<p class="fragment">Anem al navegador que se'ns ha obert a <code>http://localhost:4200/</code></p>
					</section>
					<section>
						<h2>Modificació automàtica</h2>
						<p>Accedim a <code>/src/app/app.component.ts</code> i podem provar de canviar el títol.</p>
						<p class="fragment">Proveu de canviar també els estils a /src/app/app.component.css</p>
					</section>
					<section>
						<h2>Fitxers d'una aplicació</h2>
						<p>Anem a revisar tots els fitxers que formen part de l'aplicació.</p>
					</section>
					<section>
						<h2>Exercicis</h2>
						<ul>
							<li>Proveu d'afegir HTML al component de l'aplicació</li>
							<li>Proveu d'afegir una nova propietat a l'aplicació i mostrar-la</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Arquitectura</h2>
						<img src="images/angular-architecture.png" style="background: white;" />
					</section>
					<section>
						<h2>Mòduls</h2>
						<p>Una aplicació Angular és modular per definició i està formada per 1 o N mòduls.</p>
						<p class="fragment">Cada aplicació té com a mínim un mòdul NgModule, el mòdul <em>root</em> (sovint <code>AppModule</code>).</p>
						<pre class="fragment"><code class="js">@NgModule({
  declarations: [
    ...
  ],
  imports: [
    ...
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }</code></pre>
					</section>
					<section>
						<h2>Biblioteques</h2>
						<p>Angular ens proporciona una sèrie de biblioteques que podem fer servir a les nostres aplicacions.</p>
						<p class="fragment">Podem identificar una biblioteca d'angular perquè ve precedida del prefix <code>@angular</code></p>
						<pre class="fragment"><code class="js">import { Component } from '@angular/core';</code></pre>
					</section>
					<section>
						<h2>Components</h2>
						<p>Un component controla una porció de la pantlla que anomenarem <em>vista</em>.</p>
						<p class="fragment">La lògica d'un component la definirem sempre dins d'una classe.</p>
						<p class="fragment">Angular crea, actualitza i destrueix components a mesura que l'usuari es mou per l'aplicació</p>
					</section>
					<section>
						<h2>Components</h2>
						<pre><code class="js">export class ShoppingListComponent implements OnInit {

  lineItems: LineItem[];

  constructor(private service: LineItemService) { }

  ngOnInit() {
    this.lineItems = this.service.getLineItems();
  }

}</code></pre>
					</section>
					<section>
						<h2>Plantilles</h2>
						<p>Per definir la vista d'un component usem una plantilla.</p>
						<p class="fragment">Les plantilles estan desenvolupades amb HTML i usen <em>bindings</em> d'Angular per a poder interactuar amb la informació.</p>
						<pre class="fragment"><code class="html">&lt;h2&gt;Hero List&lt;/h2&gt;

&lt;p&gt;&lt;i&gt;Pick a hero from the list&lt;/i&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li *ngFor="let hero of heroes" (click)="selectHero(hero)"&gt;
    {{hero.name}}
  &lt;/li&gt;
&lt;/ul&gt;</code></pre>
					</section>
					<section>
						<h2>Metadades</h2>
						<p>Les metadades ajuden a Angular a saber com ha de processar una classe.</p>
						<p class="fragment">Les metadades es passen a través d'anotacions com per exemple: <code>@Component</code>, <code>@Input</code> o <code>@Output</code>.</p>
						<pre class="fragment"><code class="js">@Component({
  selector:    'app-hero-list',
  templateUrl: './hero-list.component.html',
  providers:  [ HeroService ]
})
export class HeroListComponent implements OnInit {
/* . . . */
}</code></pre>
					</section>
					<section>
						<h2>Serveis</h2>
						<p>Un servei és qualsevol classe que proporciona una funcionalitat o dades, de forma concisa i precisa.</p>
						<p class="fragment">El concepte de servei no és propi d'Angular, però s'usa molt sovvint per a organitzar les aplicacions per tal de que siguin fàcilment mantenibles.</p>
						<p class="fragment">Angular es basa en el patró d'injecció de dependències.</p>
						<pre class="fragment"><code class="js">constructor(private service: HeroService) { }</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Plantilles</h2>
						<p>Les plantilles es construeixen amb HTML normal i corrent.</p>
						<p>Per motius de seguretat l'element &lt;script&gt; no està permés en una plantilla. En cas de trobar-lo, s'ignorarà.</p>
					</section>
					<section>
						<h2>Interpolació</h2>
						<p>Per a mostrar un valor en una plantilla s'usa <code>{{ }}</code></p>
						<pre><code class="html">&lt;a href="{{url}}"&gt;Hi {{user.name}}. How are you?.&lt;/a&gt;</code></pre>
						<p class="fragment">Les expressions usades poden referir-se a propietats del context de la plantilla.</p>
					</section>
					<section>
						<h2>Pipes</h2>
						<p>El resultat d'una expressió es pot transformar abans de mostrar-se en una plantilla amb una pipe.</p>
						<pre><code class="html">&lt;h2&gt;{{title | uppercase}}&lt;/h2&gt;</code></pre>
						<p class="fragment">I fins i tot podent tenir paràmetres</p>
						<pre class="fragment"><code class="html">&lt;p&gt;Birthdate: {{birthdate | date:'longDate'}}&lt;/p&gt;</code></pre>
					</section>
					<section>
						<h2>NgForOf</h2>
						<p>Serveix per a presentar una llista de valors en una plantilla</p>
						<pre><code class="html">&lt;div *ngFor="let hero of heroes; let i=index;"&gt;
  ({{i}}) {{hero.name}}
&lt;/div&gt;</code></pre>
						<p class="fragment">A més a més de l'índex, permet obtenir altres valors del bucle com booleans indicant si és el primer o el darrer valor, o si és un valor parell o senar.</p>
					</section>
					<section>
						<h2>NgIf</h2>
						<p>Es pot afegir o eliminar un element al DOM aplicant aquesta directiva a un element.</p>
						<pre><code class="html">&lt;div *ngIf="heroes.length > 3"&gt;
  There is a lot of heroes!
&lt;/div&gt;</code></pre>
						<p class="fragment">No confonguem eliminar amb amagar!</p>
					</section>
					<section>
						<h2>Exercici - Shopping list</h2>
						<p>Modifiqueu la vostra aplicació de prova per tal de tenir la següent estructura</p>
						<ul>
							<li>Una classe que representi un element d'una llista de compra <code>LineItem</code> amb dues propietats: id, name</li>
							<li>El vostre component ha de crear una <code>ShoppingList: LineItem[]</code></li>
							<li>Creeu contingut de prova i mostreu-lo a la plantilla</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Data Binding</h2>
						<p>És el mecanisme per a coordinar el que veu l'usuari amb els valors de l'aplicació.</p>
						<p class="fragment">Nosaltres declarem la unió de valors i el framework fa la feina per a comunicar aquesta informació entre ells mateixos.</p>
						<p class="fragment">N'hi ha principalment de tres tipus.</p>
					</section>
					<section>
						<h2>Important</h2>
						<p>Amb aquests mètodes no establim valors als atributs de l'HTML, si no que treballem amb propietats.</p>
						<pre><code class="html">&lt;button [disabled]="isUnchanged"&gt;Save&lt;/button&gt;</code></pre>
						<p class="fragment">No estem treballant amb l'atribut <code>disabled</code> si no que amb la seva propietat!</p>
					</section>
					<section>
						<h2>Property binding</h2>
						<p>Enllaça una propietat d'un element a una propietat d'un component.</p>
						<pre><code class="html">&lt;img [src]="myImageUrl"&gt;
&lt;img bind-src="myImageUrl"&gt;</code></pre>
						<p>Ara si canvia la propietat del component <code>myImageUrl</code> canviarà de forma automàtica a l'HTML.</p>
					</section>
					<section>
						<h2>Atributs, classes i estils</h2>
						<p>Per poder establir valors a atributs (aria, svgs i span de taules) s'ha d'usar</p>
						<pre><code class="html">&lt;button [attr.aria-label]="actionName"&gt;{{actionName}} with Aria&lt;/button&gt;</code></pre>
						<p class="fragment">Per a establir valors de classes:</p>
						<pre class="fragment"><code class="html">&lt;div [class.special]="isSpecial"&gt;The class binding is special&lt;/div&gt;</code></pre>
						<p class="fragment">Per a més opcions, podeu mirar la directiva <a href="https://angular.io/guide/template-syntax#ngClass">NgClass</a></p>
					</section>
					<section>
						<h2>Atributs, classes i estils</h2>
						<p>Per a poder establir valors d'estils:</p>
						<pre><code class="html">&lt;button [style.color]="isSpecial ? 'red': 'green'"&gt;Red&lt;/button&gt;</code></pre>
						<p class="fragment">Per a establir valors amb unitats:</p>
						<pre class="fragment"><code class="html">&lt;button [style.font-size.em]="isSpecial ? 3 : 1" &gt;Big&lt;/button&gt;</code></pre>
						<p class="fragment">Per a més opcions, podeu mirar la directiva <a href="https://angular.io/guide/template-syntax#ngStyle">NgStyle</a></p>
					</section>
					<section>
						<h2>Event binding</h2>
						<p>S'utilitza per a establir valors des d'un element a un component.</p>
						<pre><code class="html">&lt;button (click)="onSave()"&gt;Save&lt;/button&gt;
&lt;button on-click="onSave()"&gt;Save&lt;/button&gt;</code></pre>
						<p class="fragment">En fer clic al botó, es crida al mètode del component.</p>
					</section>
					<section>
						<h2>Two-way binding</h2>
						<p>Aquest és el darrer dels casos: quan volem mostrar un valor a la vegada que l'estem modificant la propietat.</p>
						<p>Un cas especial és l'ús en formularis amb <code>NgModel</code> (cal importar <code>FormsModule</code>).</p>
						<pre><code class="html">&lt;input [(ngModel)]="currentHero.name"&gt;</code></pre>
					</section>
					<section>
						<h2>Exercici</h2>
						<p>Agafem la llista de la compra d'abans i afegim les següents opcions.</p>
						<ul>
							<li>Un botó per esborrar tota la llista de la compra</li>
							<li>Al fer clic en un element, es mostra un input per a poder modificar el nom de l'element de la compra i es modifica a mesura que escric</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Comunicació entre components</h2>
						<p>No es pot accedir a propietats o mètodes d'un altre component (només té accés al seu context públic).</p>
						<p class="fragment">I què fem si jo vull passar un element d'un component a un altre de diferent? Per exemple des d'un llistat a un detall? I si vull reaccionar a un esdeveniment?</p>
						<p class="fragment">Entren en joc les annotacions <code>@Input</code> i <code>@Output</code></p>
					</section>
					<section>
						<h2><code>@Input</code></h2>
						<p>En cas de voler "passar" un valor d'un component pare a un componet fill podem fer una cosa del tipus:</p>
						<pre><code class="html">&lt;app-list-detail [listItem]="selectedListItem"&gt;&lt;/app-list-detail&gt;</code></pre>
						<p class="fragment">Però si fem directament això el compilador ens donarà un missatge de violació d'accés</p>
					</section>
					<section>
						<h2><code>@Input</code></h2>
						<p>Cal definir la variable com a element d'entrada.</p>
						<pre><code class="js">@Input() listItem: ListItem;</code></pre>
						<p class="fragment">Amb això fem que el valor de <code>selectedListItem</code> es vinculi amb la propietat <code>listItem</code> del component <code>ListDetailComponent</code>.</p>
					</section>
					<section>
						<h2><code>@Output</code></h2>
						<p>En canvi, si el que volem és que un valor d'un component fill pugi cap al pare, farem servir una cosa així.</p>
						<pre><code class="html">&lt;app-list-detail (deleteExecuted)="deleteItem($event)"&gt;&lt;/app-list-detail&gt;</code></pre>
						<p class="fragment">Igualment si fem directament això el compilador ens donarà un missatge de violació.</p>
					</section>
					<section>
						<h2><code>@Output</code></h2>
						<p>Cal definir el mètode com a element de sortida.</p>
						<pre><code class="js">@Output() deleteExecuted = new EventEmitter&lt;ListItem&gt;();</code></pre>
						<p class="fragment">Amb això fem que la propietat <code>deleteExecuted</code> pugui emetre un esdeveniment informant del <code>LineItem</code> eliminat i que un altre component pugui reaccionar-hi.</p>
					</section>
					<section>
						<h2>Exemple</h2>
						<img src="images/child-to-parent.gif">
					</section>
					<section>
						<h2>Exemple</h2>
						<pre><code class="js">import { Component, EventEmitter, Input, Output } from '@angular/core';

@Component({
  selector: 'app-voter',
  template: `
    &lt;h4&gt;{{name}}&lt;/h4&gt;
    &lt;button (click)="vote(true)"  [disabled]="voted"&gt;Agree&lt;/button&gt;
    &lt;button (click)="vote(false)" [disabled]="voted"&gt;Disagree&lt;/button&gt;
  `
})
export class VoterComponent {
  @Input()  name: string;
  @Output() onVoted = new EventEmitter&lt;boolean&gt;();
  voted = false;

  vote(agreed: boolean) {
    this.onVoted.emit(agreed);
    this.voted = true;
  }
}</code></pre>
					</section>
					<section>
						<h2>Exemple</h2>
						<pre><code class="js">import { Component } from '@angular/core';

@Component({
  selector: 'app-vote-taker',
  template: `
    &lt;h2&gt;Should mankind colonize the Universe?&lt;/h2&gt;
    &lt;h3&gt;Agree: {{agreed}}, Disagree: {{disagreed}}&lt;/h3&gt;
    &lt;app-voter *ngFor="let voter of voters"
      [name]="voter"
      (onVoted)="onVoted($event)"&gt;
    &lt;/app-voter&gt;
  `
})
export class VoteTakerComponent {
  agreed = 0;
  disagreed = 0;
  voters = ['Mr. IQ', 'Ms. Universe', 'Bombasto'];

  onVoted(agreed: boolean) {
    agreed ? this.agreed++ : this.disagreed++;
  }
}</code></pre>
					</section>
					<section>
						<h2>Variable de referència en una plantilla</h2>
						<p>Podem crear una referència a un element fent servir la sintaxis <code>#var</code></p>
						<pre><code class="html">&lt;input #phone placeholder="phone number"&gt;</code></pre>
						<p class="fragment">I usar-la més endavant allà on ens interessi.</p>
						<pre class="fragment"><code class="html">&lt;button (click)="callPhone(phone.value)"&gt;Call&lt;/button&gt;</code></pre>
					</section>
					<section>
						<h2>Exemple</h2>
						<p>Les variables poden referenciar a un component, i per tant, en una plantilla podem fer una cosa com aquesta.</p>
						<pre><code class="html">&lt;h3&gt;Countdown&lt;/h3&gt;
&lt;button (click)="timer.start()"&gt;Start&lt;/button&gt;
&lt;button (click)="timer.stop()"&gt;Stop&lt;/button&gt;
&lt;div class="seconds"&gt;{{timer.seconds}}&lt;/div&gt;
&lt;app-countdown-timer #timer&gt;&lt;/app-countdown-timer&gt;</code></pre>
					</section>
					<section>
						<h2>Exercici</h2>
						<p>Seguint amb l'exemple de la ShoppingList, dividim l'aplicació en dos components, de tal forma que tinguem un component per al llistat i un altre de diferent per al detall/formulari de modificació de valors.</p>
					</section>
				</section>
				<section>
					<section>
						<h2><em>Routing</em></h2>
						<p>Sovint a les nostres aplicacions voldrem que les vistes siguin accessibles a través de certs URLs.</p>
						<p class="fragment">A Angular treballarem amb el concepte <code>Routes</code>.</p>
						<p class="fragment">Tot i que ho podem declarar a l'aplicació general, es recomana la creació d'un mòdul específic.</p>
					</section>
					<section>
						<h2>Classe base</h2>
						<p>Podem usar una classe base com la següent:</p>
						<pre><code class="js">import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

@NgModule({
  exports: [ RouterModule ]
})
export class AppRoutingModule {}</code></pre>
					</section>
					<section>
						<h2>Definició d'una ruta</h2>
						<p>Per definir rutes hem de fer:</p>
						<pre><code class="js">const routes: Routes = [
  { path: 'heroes', component: HeroesComponent }
];</code></pre>
						<p class="fragment">I afegir-ho a <code>@NgModule.imports</code>:</p>
						<pre class="fragment"><code class="js">imports: [ RouterModule.forRoot(routes) ],</code></pre>
					</section>
					<section>
						<h2>Modificació de l'aplicació</h2>
						<p>Ara cal obrir la nostra <code>AppComponent</code> per exemple i afegir:</p>
						<pre><code class="html">&lt;h1&gt;{{title}}&lt;/h1&gt;
&lt;nav&gt;
  &lt;a routerLink="/heroes"&gt;Heroes&lt;/a&gt;
&lt;/nav&gt;
&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></pre>
						<p class="fragment">Ara dins de <code>&lt;router-outlet&gt;</code> es mostrarà el component definit per la ruta</p>
					</section>
					<section>
						<h2>Rutes per defecte</h2>
						<p>Podem definir una ruta per defecte perquè hi navegui sempre quan anem a l'arrel de l'aplicació.</p>
						<pre><code class="js">{ path: '', redirectTo: '/dashboard', pathMatch: 'full' }</code></pre>
					</section>
					<section>
						<h2>Rutes comodí</h2>
						<p>Ens pot interessar interceptar qualsevol ruta que no estigui definida per, per exemple, enviar-la a la típica pàgina 404.</p>
						<pre><code class="js">{ path: '**', component: PageNotFoundComponent }</code></pre>
					</section>
					<section>
						<h2>Rutes amb paràmetres</h2>
						<p>Hi ha certes pàgines que ens pot interessar accedir-hi via una adreça amb paràmetres, del tipus <code>/detail/23</code>. Per fer-ho podem declarar:</p>
						<pre><code class="js">{ path: 'detail/:id', component: HeroDetailComponent }</code></pre>
					</section>
					<section>
						<h2>Ús de paràmetres de l'URL</h2>
						<p>Si volem a més a més, obtenir el valor de l'URL per a poder mostrar aquell valor específic, caldrà injectar un servei al constructor del component amb el que treballem.</p>
						<pre><code class="js">constructor(private route: ActivatedRoute) {}</code></pre>
					</section>
					<section>
						<h2>Ús de paràmetres de l'URL</h2>
						<p>Allà on vulguem usar el valor, el podem obtenir del paràmetre de l'URL fent:</p>
						<pre><code class="js">const id = this.route.snapshot.paramMap.get('id');</code></pre>
						<p class="fragment">Cal tenir present que tots els paràmetres obtinguts de l'URL són strings. Si volem usar com a nombre, caldrà transformar-lo.</p>
					</section>
					<section>
						<h2>Exercici</h2>
						<p>Anem a transformarla nostra aplicació de la llista de la compra per tal de poder ser accessible via <code>/shopping-list</code> i el seu detall mitjançant <code>/list-item/&lt;id&gt;</code></p>
						<p>Extra: afegiu opcions per a poder tenir una pàgina d'error.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Formularis</h2>
						<p>Existeixen dues formes diferents de poder crear formularis a Angular:</p>
						<ul>
							<li><em>Template-driven Forms</em></li>
							<li><em>Reactive Forms</em></li>
						</ul>
					</section>
					<section>
						<h2><em>Template-driven Forms</em></h2>
						<p>Es basa en la directiva <code>ngModel</code> que ja coneixem.</p>
						<p class="fragment">Tota la lògica del formulari es defineix a la plantilla (mapping, validacions, etc.).</p>
						<p class="fragment">Addient per a petits formularis però ràpidament es queda curt.</p>
					</section>
					<section>
						<h2>Exemple</h2>
						<pre><code class="html">&lt;form #form="ngForm" (ngSubmit)="onSubmit()"&gt;
  &lt;p&gt;
    &lt;label&gt;First Name:&lt;/label&gt;
    &lt;input type="text" [(ngModel)]="user.firstName" name="firstName" required&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label&gt;Last Name:&lt;/label&gt;
    &lt;input type="text" [(ngModel)]="user.LastName" name="lastName" required&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;button type="submit" [disabled]="!f.valid"&gt;Submit&lt;/button&gt;
  &lt;/p&gt;
&lt;/form&gt;</code></pre>
					</section>
					<section>
						<h2>Exemple</h2>
						<p>En aquest cas, gràcies al <em>two-way binding</em> la nostra funció de submit pot quedar ben senzilla.</p>
						<pre><code class="js">onSubmit() {
  console.log(this.user);
  this.user.save();
}</code></pre>
					</section>
					<section>
						<h2>Notes</h2>
						<p>En cas de no voler <em>two-way binding</em>, podem només usar en una direcció <code>[ngModel]</code> i fer:</p>
						<pre><code class="html">&lt;form #form="ngForm" (ngSubmit)="onSubmit(form)"&gt;</code></pre>
						<pre><code class="js">onSubmit({value}) {
  this.user.firstName = value.firstName;
  this.user.lastName = value.lastName;
  this.user.save();
}</code></pre>
					</section>
					<section>
						<h2>Desavantatges</h2>
						<p>Si anem afegint lògica al formulari, validacions, etc. aquests es torna difícil de llegir i de mantenir. A més, no podem fer proves unitàries del formularis!</p>
						<p class="fragment">Imaginem-nos que necessitem fer validacions dependents d'un altre camp, com per exemple, comprovar que dos camps tenen el mateix valor.</p>
						<p class="fragment">Es necessita una versió més avançada de declaració de formularis.</p>
					</section>
					<section>
						<h2><em>Reactive Forms</em></h2>
						<p>També anomenats <em>Model driven</em> és una forma de definir formularis des de codi, tot fent independent la seva modulació HTML de la seva modulació en codi.</p>
						<p class="fragment">Es basa en el mòdul <em>ReactiveFormsModule</em></p>
						<pre class="fragment"><code class="js">import {ReactiveFormsModule} from "@angular/forms";</code></pre>
					</section>
					<section>
						<h2>Exemple</h2>
						<pre><code class="html">&lt;form [formGroup]="userForm" (ngSubmit)="onSubmit()"&gt;
  &lt;p&gt;
    &lt;label&gt;First Name:&lt;/label&gt;
    &lt;input type="text" formControlName="firstName"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label&gt;Last Name:&lt;/label&gt;
    &lt;input type="text" formControlName="lastName"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;button type="submit" [disabled]="!f.valid"&gt;Submit&lt;/button&gt;
  &lt;/p&gt;
&lt;/form&gt;</code></pre>
					</section>
					<section>
						<h2>Agnòstic</h2>
						<p>Si ens fixem, ara tenim una directiva <code>formGroup</code> associada a una variable anomenada <code>userForm</code></p>
						<p class="fragment">Ara la nostra plantilla no té informació sobre validacions. Aquestes residiran al controlador, el qual pot ser provat unitàriament.</p>
					</section>
					<section>
						<h2>Exemple</h2>
						<p>El nostre controlador tindrà la següent pinta.</p>
						<pre><code class="js">export class UserFormComponent {
  userForm: FormGroup;

  constructor(private fb: FormBuilder) {
    this.createForm();
  }

  createForm() {
    this.userForm = this.fb.group({
      firstName: ['', Validators.required ],
      lastName: ['', Validators.required ]
    });
  }

  onSubmit() {
		// Show formModel.
    console.log(this.userForm.value);
  }
}</code></pre>
					</section>
					<section>
						<h2>Avantatges</h2>
						<p>Això ens permet poder tenir el model completament independent del formulari (formularis parcials).</p>
						<p class="fragment">A més, se'ns obre la possibilitat de poder aplicar programació reactiva.</p>
					</section>
					<section>
						<h2>Establir valors del formulari</h2>
						<p>Podem establir tots els valors d'un formulari amb <code>setValue</code>.</p>
						<pre><code class="js">this.form.setValue({
  firstName: this.user.firstName,
  lastName: this.user.lastName
});</code></pre>
						<pre class="fragment"><code class="js">this.form.setValue(user);</code></pre>
					</section>
					<section>
						<h2>Establir valors del formulari</h2>
						<p>Però també podem especificar només valors per part dels elements amb <code>patchValue</code>.</p>
						<pre><code class="js">this.form.patchValue({
  firstName: this.user.firstName
});</code></pre>
						<pre class="fragment"><code class="js">this.form.setValue(user);</code></pre>
					</section>
					<section>
						<h2>Bonus: reset d'un formulari</h2>
						<p>Podem esborrar tots els camps (i estat) d'un formulari fent servir la funció <code>reset()</code></p>
						<pre><code class="js">this.form.reset();</code></pre>
					</section>
					<section>
						<h2>Exercici</h2>
						<p>Afegim un formulari al shoppingList per tal de poder afegir nous elements a la llista</p>
						<p>Ampliem el model de dades per a especificar nom de l'element (obligatori) i quantitat, per defecte 1.</p>
						<p>Usar reactive forms.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Consumir serveis REST</h2>
						<p>Per a fer-ho farem servir un servei anomenat <code>HttpClient</code> disponible mitjançant <code>HttpClientModule</code>.</p>
						<p class="fragment">Hem d'injectar el servei al nostre component per tal de poder-lo fer servir.</p>
						<pre class="fragment"><code class="js">constructor(private http: HttpClient) {}</code></pre>
					</section>
					<section>
						<h2><code>HttpClient</code></h2>
						<p>Usa l'objecte <code>XMLHttpRequest</code> propi dels navegadors per a poder fer peticions dels següents tipus:</p>
						<ul>
							<li>get</li>
							<li>post</li>
							<li>put</li>
							<li>delete</li>
							<li>patch</li>
							<li>head</li>
							<li>jsonp</li>
						</ul>
					</section>
					<section>
						<h2>Consultar dades</h2>
						<p>Per a llançar una petició de consulta, només cal cridar al mètode <code>get()</code> de l'objecte i subscriure'ns-hi.</p>
						<pre><code class="js">this.http.get(url).subscribe(data => {
  console.log(data);
});</code></pre>
						<p class="fragment">Tècnicament, qui executa la petició és la crida a <code>subscribe()</code>. Sense això, no s'executaria.</p>
					</section>
					<section>
						<h2>Resposta</h2>
						<p>Aquesta crida retornaria a <code>data</code> un anònim <code>Object</code>, imaginem-nos, amb diverses propietats, entre les quals, <code>name</code> i <code>surname</code>.
						<p class="fragment">Només podríem accedir als seus valors fent: <code class="js">data['name']</code> o <code class="js">data['surname']</code>.
						<p class="fragment">Però el que de debò ens agradaria és poder accedir mitjançant la notació del punt <code class="js">data.name</code> o <code class="js">data.surname</code>.
					</section>
					<section>
						<h2>Resposta</h2>
						<p>El que podem fer és, per exemple, fer <em>cast</em> de la resposta a un tipus que disposi de les propietats corresponents.</p>
						<p class="fragment">Per això, podem definir una <em>interface</em> amb les propietats que ens interessi:</p>
						<pre class="fragment"><code class="js">interface UserResponse {
  name: string,
  surname: string
}</code></pre>
					</section>
					<section>
						<h2>Resposta</h2>
						<p>Ara ja podem fer <em>cast</em> en la resposta de la petició:</p>
						<pre><code class="js">this.http.get&lt;UserResponse&gt;(url).subscribe(data => {
  console.log('User name: ' + data.name);
  console.log('User surname: ' + data.surname);
});</code></pre>
					</section>
					<section>
						<h2>Gestió dels errors</h2>
						<pre><code class="js">this.http.get&lt;UserResponse&gt;(url).subscribe(
  data => {
    console.log('User name: ' + data.name);
    console.log('User surname: ' + data.surname);
  },
  err => {
    console.log('Error occurred.');
  }
);</code></pre>
						<p class="fragment">Si volem accedir a més informació de l'error, podem definir el paràmetre com de tipus:</p>
						<pre class="fragment"><code>(err: HttpErrorResponse)</code></pre>
					</section>
					<section>
						<h2>Fer un post a servidor</h2>
						<pre><code class="js">const req = this.http.post(url, data)
.subscribe(
  res => {
    console.log(res);
  },
  err => {
    console.log("Error occured");
  }
);</code></pre>
					</section>
					<section>
						<h2>Exercici</h2>
						<p>Usant https://jsonplaceholder.typicode.com/, anem a construir una aplicació que consulti l'endpoint /posts i llisti la seva resposta.</p>
						<p>Una vegada fet això, fem un formulari amb dos camps, title i body, i al fer clic a un botó, envïi els valors a /posts amb userId = 2.</p>
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
